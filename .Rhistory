#0 (no initial match), 0 (no negotiation), 1 (others' move)
#1 (no initial match), 0 (no negotiation), 1 (others' move)
#0 (no initial match), 1 (failed negotiation), 1 (others' move)
#1 (no initial match), 1 (failed negotiation), 1 (others' move)
#function for payoff matrix construction (row is self, column is other)
payoff_matrix_constructor <- function(n_moves, off_diag, m, sd){
#generate payoff matrix with values from normal distribution around cost
#payoffs <- matrix(rnorm(n_moves*n_moves, mean = off_diag, sd = sd), nrow = n_moves, ncol = n_moves)
payoffs <- matrix(off_diag, nrow = n_moves, ncol = n_moves)
#replace diagonal with values from normal distribution around 0
diag(payoffs) <- rnorm(n_moves, mean = m, sd = sd)
#return the matrix
return(payoffs)
}
#play coordination game with an opponent (b) using an arbitrary strategy and preference
#strat is a 3L vector with a 0/1 for advertisement, negotiation, and matching
coord_game <- function(strat, pref, a, b, status_quo, neg_cost, data){
#get advertised move
advertised_a <- ifelse(strat[1] == 0, pref, status_quo)
advertised_b <- ifelse(data$advertisement[b] == 0, data$pref[b], status_quo)
#if they match, return payoff of advertised move
if(advertised_a == advertised_b){return(diag(data$payoffs[[a]])[advertised_a])}
#if they do not match and both are negotiators, return payoff of move from agent with highest power
if(advertised_a != advertised_b & strat[2] == 1 & data$negotiation[b] == 1){
ifelse(data$power[a] > data$power[b],
return(diag(data$payoffs[[a]])[advertised_a] - neg_cost),
return(diag(data$payoffs[[a]])[advertised_b] - neg_cost))
}
#if they do not match and only one or neither are negotiators
if(advertised_a != advertised_b & (strat[2] == 0 | data$negotiation[b] == 0)){
#get chosen moves based on matching strategies
chosen_a <- ifelse(strat[3] == 0, advertised_a, advertised_b)
chosen_b <- ifelse(data$matching[b] == 0, advertised_b, advertised_a)
#return appropriate payoff
ifelse(chosen_a == chosen_b,
return(diag(data$payoffs[[a]])[chosen_a]),
return(data$payoffs[[a]][chosen_a, chosen_b]))
}
}
#nested coordination game, to iterate through possible strategies for a against b
#returned matrix has prefs on columns and strats on rows
nest_coord_game <- function(a, b, status_quo, neg_cost, data){
#store possible strategies as vectors
poss_strats <- list(c(0, 0, 0), c(1, 0, 0), c(0, 1, 0), c(0, 0, 1),
c(1, 0, 1), c(1, 1, 0), c(0, 1, 1), c(1, 1, 1))
#iterate through each possible preference
return(sapply(1:n_moves, function(x){
#iterate through possible strategies
sapply(1:length(poss_strats), function(y){coord_game(poss_strats[[y]], x, a, b, status_quo, neg_cost, data)})
}))
}
#ewa observation function, to update the number of previous rounds of experience
observation <- function(n, phi = 0, kappa = 0){phi*(1 - kappa)*n + 1}
#ewa attraction function, with optional loss aversion
attraction <- function(a, n, phi, delta, i, pi, kappa, loss_averse = FALSE, m_diag){
#if loss_averse == TRUE
if(loss_averse){
#then set delta to 0 when pi above average
ifelse(pi < m_diag,
(phi*n*a + (delta + (1 - delta)*i)*pi)/observation(n, phi, kappa),
(phi*n*a + i*pi)/observation(n, phi, kappa))
} else{
(phi*n*a + (delta + (1 - delta)*i)*pi)/observation(n, phi, kappa)
}
}
#ewa softmax function
softmax <- function(a, a_all, lambda){exp(lambda*a)/sum(exp(lambda*a_all))}
#full ewa function, which requires current attraction and payoff of both strategies
#when delta != 0, a, strat_used, and pi are vectors (strat_used is 0s and 1s, where 1 denotes which was used)
ewa <- function(a, n, phi, delta, strat_used, pi, kappa, lambda, loss_averse = FALSE, m_diag){
#if strat_used is a single number, convert to vector
if(length(strat_used) == 1){
temp <- rep(0, length(a))
temp[strat_used] <- 1
strat_used <- temp
}
#update attractions based on payoffs (pi)
a_new <- sapply(1:length(a), function(x){attraction(a[x], n, phi, delta, strat_used[x], pi[x], kappa, loss_averse, m_diag)})
#update (global) n
n_new <- observation(n, phi, kappa)
#get probabilities based on new attractions
probs <- sapply(1:length(a_new), function(x){softmax(a_new[x], a_new, lambda)})
#return everything named list
return(list(a = a_new, n = n_new, probs = probs))
}
#full model function
#ewa parameters:
#n (prior for n)
#phi (weight given to new experience) (0-1)
#delta (whether only used strategy is updated (0) or used and unused strategies are updated (1)) (0-1)
#kappa (rate at which previous information is depreciated) (0-1)
#lambda (randomness in softmax, where 0 is completely random and larger values are more deterministic)
#special conditions:
#average reinforcement learning: delta = 0, kappa = 0, n = 1... (simplified: (phi*a + i*pi)/(phi + 1))
#cumulative reinforcement learning: delta = 0, kappa = 1, n = 1... (simplifed: phi*a + i*pi)
#weighted fictitious play: delta = 1, kappa = 0, n = 1... (simplified: (phi*a + pi)/(phi + 1))
#fictitious play: phi = 1, delta = 1, kappa = 0, n = 1... (simplified: (a + pi)/2))
#cournot best response: phi = 0, delta = 1, kappa = 0, n = 1... (simplified: pi)
pop_size <- 10
t <- 10
status_quo <- 1
priors <- c(5, 0, 0, 0)
n_moves <- 4
init_move_probs <- c(1, 1, 1, 1)
pref_payoff <- FALSE
default_strat <- c(0, 0, 0)
m_diag <- 5
off_diag <- 0
sd <- 1
neg_cost <- 0.5
n <- 1
phi <- 0.5
delta <- 0
kappa <- 0
lambda <- 1
loss_averse <- TRUE
static_prefs <- FALSE
cores <- 7
#initialize population of agents with
agents <- data.table::data.table(pref = sample(n_moves, pop_size, replace = TRUE, prob = init_move_probs),
advertisement = default_strat[1], negotiation = default_strat[2], matching = default_strat[3],
payoffs = lapply(1:pop_size, function(x){payoff_matrix_constructor(n_moves, off_diag, m_diag, sd)}),
power = sapply(1:pop_size, function(x){rnorm(1, 5, 1)}),
a_moves = lapply(1:pop_size, function(x){c(priors[1], rep(0, n_moves - 1))}),
a_advertisement = lapply(1:pop_size, function(x){c(priors[2], 0)}),
a_negotiation = lapply(1:pop_size, function(x){c(priors[3], 0)}),
a_matching = lapply(1:pop_size, function(x){c(priors[4], 0)}))
#if agents prefer their highest payoff move, then overwrite accordingly
if(pref_payoff){agents$pref <- sapply(1:pop_size, function(x){which.max(diag(agents$payoffs[[x]]))})}
#create output object
output <- list()
output[[1]] <- agents
i <- 2
#generate data frame of duos to coordinate (fully-connected population)
duos <- data.frame(x = sample(1:pop_size, pop_size/2), y = NA)
duos$y <- sample(c(1:pop_size)[-duos$x])
#iterate through duos in parallel with mclapply
coord_game_results <- parallel::mclapply(1:nrow(duos), function(j){
if(!static_prefs){
#calculate payoffs from different moves
move_payoffs_a <- sapply(1:n_moves, function(x){coord_game(as.numeric(agents[duos[j, 1], 2:4]), x, duos[j, 1], duos[j, 2], status_quo, neg_cost, agents)})
move_payoffs_b <- sapply(1:n_moves, function(x){coord_game(as.numeric(agents[duos[j, 2], 2:4]), x, duos[j, 2], duos[j, 1], status_quo, neg_cost, agents)})
#solve ewa for moves
move_ewa_a <- ewa(a = agents$a_moves[[duos[j, 1]]], n = n, phi = phi, delta = delta, strat_used = agents$pref[duos[j, 1]],
pi = move_payoffs_a, kappa = kappa, lambda = lambda, loss_averse = loss_averse)
move_ewa_b <- ewa(a = agents$a_moves[[duos[j, 2]]], n = n, phi = phi, delta = delta, strat_used = agents$pref[duos[j, 2]],
pi = move_payoffs_b, kappa = kappa, lambda = lambda, loss_averse = loss_averse)
}
#calculate payoffs for advertisement
advertisement_payoffs_a <- sapply(c(0, 1), function(x){coord_game(c(x, agents$negotiation[duos[j, 1]], agents$matching[duos[j, 1]]),
agents$pref[duos[j, 1]], duos[j, 1], duos[j, 2], status_quo, neg_cost, agents)})
advertisement_payoffs_b <- sapply(c(0, 1), function(x){coord_game(c(x, agents$negotiation[duos[j, 2]], agents$matching[duos[j, 2]]),
agents$pref[duos[j, 2]], duos[j, 2], duos[j, 1], status_quo, neg_cost, agents)})
#solve ewa for advertisement
advertisement_ewa_a <- ewa(a = agents$a_advertisement[[duos[j, 1]]], n = n, phi = phi, delta = delta, strat_used = agents$advertisement[duos[j, 1]] + 1,
pi = advertisement_payoffs_a, kappa = kappa, lambda = lambda, loss_averse = loss_averse)
advertisement_ewa_b <- ewa(a = agents$a_advertisement[[duos[j, 2]]], n = n, phi = phi, delta = delta, strat_used = agents$advertisement[duos[j, 2]] + 1,
pi = advertisement_payoffs_b, kappa = kappa, lambda = lambda, loss_averse = loss_averse)
#calculate payoffs for negotiation
negotiation_payoffs_a <- sapply(c(0, 1), function(x){coord_game(c(agents$advertisement[duos[j, 1]], x, agents$matching[duos[j, 1]]),
agents$pref[duos[j, 1]], duos[j, 1], duos[j, 2], status_quo, neg_cost, agents)})
negotiation_payoffs_b <- sapply(c(0, 1), function(x){coord_game(c(agents$advertisement[duos[j, 2]], x, agents$matching[duos[j, 2]]),
agents$pref[duos[j, 2]], duos[j, 2], duos[j, 1], status_quo, neg_cost, agents)})
#solve ewa for negotiation
negotiation_ewa_a <- ewa(a = agents$a_negotiation[[duos[j, 1]]], n = n, phi = phi, delta = delta, strat_used = agents$negotiation[duos[j, 1]] + 1,
pi = negotiation_payoffs_a, kappa = kappa, lambda = lambda, loss_averse = loss_averse)
negotiation_ewa_b <- ewa(a = agents$a_negotiation[[duos[j, 2]]], n = n, phi = phi, delta = delta, strat_used = agents$negotiation[duos[j, 2]] + 1,
pi = negotiation_payoffs_b, kappa = kappa, lambda = lambda, loss_averse = loss_averse)
#calculate payoffs for matching
matching_payoffs_a <- sapply(c(0, 1), function(x){coord_game(c(agents$advertisement[duos[j, 1]], agents$negotiation[duos[j, 1]], x),
agents$pref[duos[j, 1]], duos[j, 1], duos[j, 2], status_quo, neg_cost, agents)})
matching_payoffs_b <- sapply(c(0, 1), function(x){coord_game(c(agents$advertisement[duos[j, 2]], agents$negotiation[duos[j, 2]], x),
agents$pref[duos[j, 2]], duos[j, 2], duos[j, 1], status_quo, neg_cost, agents)})
#solve ewa for matching
matching_ewa_a <- ewa(a = agents$a_matching[[duos[j, 1]]], n = n, phi = phi, delta = delta, strat_used = agents$matching[duos[j, 1]] + 1,
pi = matching_payoffs_a, kappa = kappa, lambda = lambda, loss_averse = loss_averse)
matching_ewa_b <- ewa(a = agents$a_matching[[duos[j, 2]]], n = n, phi = phi, delta = delta, strat_used = agents$matching[duos[j, 2]] + 1,
pi = matching_payoffs_b, kappa = kappa, lambda = lambda, loss_averse = loss_averse)
#sample new preference and strategies for agent a
if(!static_prefs){
pref_strats_a <- c(sample(n_moves, 1, prob = move_ewa_a$probs), sample(c(0, 1), 1, prob = advertisement_ewa_a$probs),
sample(c(0, 1), 1, prob = negotiation_ewa_a$probs), sample(c(0, 1), 1, prob = matching_ewa_a$probs))
} else{
pref_strats_a <- c(sample(c(0, 1), 1, prob = advertisement_ewa_a$probs),
sample(c(0, 1), 1, prob = negotiation_ewa_a$probs), sample(c(0, 1), 1, prob = matching_ewa_a$probs))
}
#sample new preference and strategies for agent b
if(!static_prefs){
pref_strats_b <- c(sample(n_moves, 1, prob = move_ewa_b$probs), sample(c(0, 1), 1, prob = advertisement_ewa_b$probs),
sample(c(0, 1), 1, prob = negotiation_ewa_b$probs), sample(c(0, 1), 1, prob = matching_ewa_b$probs))
} else{
pref_strats_b <- c(sample(c(0, 1), 1, prob = advertisement_ewa_b$probs),
sample(c(0, 1), 1, prob = negotiation_ewa_b$probs), sample(c(0, 1), 1, prob = matching_ewa_b$probs))
}
#return objects
if(!static_prefs){
return(list(a = list(pref_strats = pref_strats_a,
move_a = move_ewa_a$a,
advertisement_a = advertisement_ewa_a$a,
negotiation_a = negotiation_ewa_a$a,
matching_a = matching_ewa_a$a),
b = list(pref_strats = pref_strats_b,
move_a = move_ewa_b$a,
advertisement_a = advertisement_ewa_b$a,
negotiation_a = negotiation_ewa_b$a,
matching_a = matching_ewa_b$a)))
} else{
return(list(a = list(pref_strats = pref_strats_a,
advertisement_a = advertisement_ewa_a$a,
negotiation_a = negotiation_ewa_a$a,
matching_a = matching_ewa_a$a),
b = list(pref_strats = pref_strats_b,
advertisement_a = advertisement_ewa_b$a,
negotiation_a = negotiation_ewa_b$a,
matching_a = matching_ewa_b$a)))
}
}, mc.cores = cores)
#generate data frame of duos to coordinate (fully-connected population)
duos <- data.frame(x = sample(1:pop_size, pop_size/2), y = NA)
duos$y <- sample(c(1:pop_size)[-duos$x])
#calculate payoffs for advertisement
advertisement_payoffs_a <- sapply(c(0, 1), function(x){coord_game(c(x, agents$negotiation[duos[j, 1]], agents$matching[duos[j, 1]]),
agents$pref[duos[j, 1]], duos[j, 1], duos[j, 2], status_quo, neg_cost, agents)})
j <- 1
#calculate payoffs for advertisement
advertisement_payoffs_a <- sapply(c(0, 1), function(x){coord_game(c(x, agents$negotiation[duos[j, 1]], agents$matching[duos[j, 1]]),
agents$pref[duos[j, 1]], duos[j, 1], duos[j, 2], status_quo, neg_cost, agents)})
advertisement_payoffs_b <- sapply(c(0, 1), function(x){coord_game(c(x, agents$negotiation[duos[j, 2]], agents$matching[duos[j, 2]]),
agents$pref[duos[j, 2]], duos[j, 2], duos[j, 1], status_quo, neg_cost, agents)})
#solve ewa for advertisement
advertisement_ewa_a <- ewa(a = agents$a_advertisement[[duos[j, 1]]], n = n, phi = phi, delta = delta, strat_used = agents$advertisement[duos[j, 1]] + 1,
pi = advertisement_payoffs_a, kappa = kappa, lambda = lambda, loss_averse = loss_averse)
model <- function(pop_size, t, status_quo = 1, priors = c(0, 0, 0, 0), n_moves = 4, init_move_probs = c(1, 1, 1, 1),
default_strat = c(0, 0, 0), m_diag = 5, off_diag = 0, sd = 1, neg_cost = 0.5,
n = 1, phi, delta = 0, kappa, lambda, pref_payoff = FALSE, loss_averse = FALSE, static_prefs = FALSE, cores = 7){
#initialize population of agents with
agents <- data.table::data.table(pref = sample(n_moves, pop_size, replace = TRUE, prob = init_move_probs),
advertisement = default_strat[1], negotiation = default_strat[2], matching = default_strat[3],
payoffs = lapply(1:pop_size, function(x){payoff_matrix_constructor(n_moves, off_diag, m_diag, sd)}),
power = sapply(1:pop_size, function(x){rnorm(1, 5, 1)}),
a_moves = lapply(1:pop_size, function(x){c(priors[1], rep(0, n_moves - 1))}),
a_advertisement = lapply(1:pop_size, function(x){c(priors[2], 0)}),
a_negotiation = lapply(1:pop_size, function(x){c(priors[3], 0)}),
a_matching = lapply(1:pop_size, function(x){c(priors[4], 0)}))
#if agents prefer their highest payoff move, then overwrite accordingly
if(pref_payoff){agents$pref <- sapply(1:pop_size, function(x){which.max(diag(agents$payoffs[[x]]))})}
#create output object
output <- list()
output[[1]] <- agents
for(i in 2:t){
#generate data frame of duos to coordinate (fully-connected population)
duos <- data.frame(x = sample(1:pop_size, pop_size/2), y = NA)
duos$y <- sample(c(1:pop_size)[-duos$x])
#iterate through duos in parallel with mclapply
coord_game_results <- parallel::mclapply(1:nrow(duos), function(j){
if(!static_prefs){
#calculate payoffs from different moves
move_payoffs_a <- sapply(1:n_moves, function(x){coord_game(as.numeric(agents[duos[j, 1], 2:4]), x, duos[j, 1], duos[j, 2], status_quo, neg_cost, agents)})
move_payoffs_b <- sapply(1:n_moves, function(x){coord_game(as.numeric(agents[duos[j, 2], 2:4]), x, duos[j, 2], duos[j, 1], status_quo, neg_cost, agents)})
#solve ewa for moves
move_ewa_a <- ewa(a = agents$a_moves[[duos[j, 1]]], n = n, phi = phi, delta = delta, strat_used = agents$pref[duos[j, 1]],
pi = move_payoffs_a, kappa = kappa, lambda = lambda, loss_averse = loss_averse, m_diag = m_diag)
move_ewa_b <- ewa(a = agents$a_moves[[duos[j, 2]]], n = n, phi = phi, delta = delta, strat_used = agents$pref[duos[j, 2]],
pi = move_payoffs_b, kappa = kappa, lambda = lambda, loss_averse = loss_averse, m_diag = m_diag)
}
#calculate payoffs for advertisement
advertisement_payoffs_a <- sapply(c(0, 1), function(x){coord_game(c(x, agents$negotiation[duos[j, 1]], agents$matching[duos[j, 1]]),
agents$pref[duos[j, 1]], duos[j, 1], duos[j, 2], status_quo, neg_cost, agents)})
advertisement_payoffs_b <- sapply(c(0, 1), function(x){coord_game(c(x, agents$negotiation[duos[j, 2]], agents$matching[duos[j, 2]]),
agents$pref[duos[j, 2]], duos[j, 2], duos[j, 1], status_quo, neg_cost, agents)})
#solve ewa for advertisement
advertisement_ewa_a <- ewa(a = agents$a_advertisement[[duos[j, 1]]], n = n, phi = phi, delta = delta, strat_used = agents$advertisement[duos[j, 1]] + 1,
pi = advertisement_payoffs_a, kappa = kappa, lambda = lambda, loss_averse = loss_averse, m_diag = m_diag)
advertisement_ewa_b <- ewa(a = agents$a_advertisement[[duos[j, 2]]], n = n, phi = phi, delta = delta, strat_used = agents$advertisement[duos[j, 2]] + 1,
pi = advertisement_payoffs_b, kappa = kappa, lambda = lambda, loss_averse = loss_averse, m_diag = m_diag)
#calculate payoffs for negotiation
negotiation_payoffs_a <- sapply(c(0, 1), function(x){coord_game(c(agents$advertisement[duos[j, 1]], x, agents$matching[duos[j, 1]]),
agents$pref[duos[j, 1]], duos[j, 1], duos[j, 2], status_quo, neg_cost, agents)})
negotiation_payoffs_b <- sapply(c(0, 1), function(x){coord_game(c(agents$advertisement[duos[j, 2]], x, agents$matching[duos[j, 2]]),
agents$pref[duos[j, 2]], duos[j, 2], duos[j, 1], status_quo, neg_cost, agents)})
#solve ewa for negotiation
negotiation_ewa_a <- ewa(a = agents$a_negotiation[[duos[j, 1]]], n = n, phi = phi, delta = delta, strat_used = agents$negotiation[duos[j, 1]] + 1,
pi = negotiation_payoffs_a, kappa = kappa, lambda = lambda, loss_averse = loss_averse, m_diag = m_diag)
negotiation_ewa_b <- ewa(a = agents$a_negotiation[[duos[j, 2]]], n = n, phi = phi, delta = delta, strat_used = agents$negotiation[duos[j, 2]] + 1,
pi = negotiation_payoffs_b, kappa = kappa, lambda = lambda, loss_averse = loss_averse, m_diag = m_diag)
#calculate payoffs for matching
matching_payoffs_a <- sapply(c(0, 1), function(x){coord_game(c(agents$advertisement[duos[j, 1]], agents$negotiation[duos[j, 1]], x),
agents$pref[duos[j, 1]], duos[j, 1], duos[j, 2], status_quo, neg_cost, agents)})
matching_payoffs_b <- sapply(c(0, 1), function(x){coord_game(c(agents$advertisement[duos[j, 2]], agents$negotiation[duos[j, 2]], x),
agents$pref[duos[j, 2]], duos[j, 2], duos[j, 1], status_quo, neg_cost, agents)})
#solve ewa for matching
matching_ewa_a <- ewa(a = agents$a_matching[[duos[j, 1]]], n = n, phi = phi, delta = delta, strat_used = agents$matching[duos[j, 1]] + 1,
pi = matching_payoffs_a, kappa = kappa, lambda = lambda, loss_averse = loss_averse, m_diag = m_diag)
matching_ewa_b <- ewa(a = agents$a_matching[[duos[j, 2]]], n = n, phi = phi, delta = delta, strat_used = agents$matching[duos[j, 2]] + 1,
pi = matching_payoffs_b, kappa = kappa, lambda = lambda, loss_averse = loss_averse, m_diag = m_diag)
#sample new preference and strategies for agent a
if(!static_prefs){
pref_strats_a <- c(sample(n_moves, 1, prob = move_ewa_a$probs), sample(c(0, 1), 1, prob = advertisement_ewa_a$probs),
sample(c(0, 1), 1, prob = negotiation_ewa_a$probs), sample(c(0, 1), 1, prob = matching_ewa_a$probs))
} else{
pref_strats_a <- c(sample(c(0, 1), 1, prob = advertisement_ewa_a$probs),
sample(c(0, 1), 1, prob = negotiation_ewa_a$probs), sample(c(0, 1), 1, prob = matching_ewa_a$probs))
}
#sample new preference and strategies for agent b
if(!static_prefs){
pref_strats_b <- c(sample(n_moves, 1, prob = move_ewa_b$probs), sample(c(0, 1), 1, prob = advertisement_ewa_b$probs),
sample(c(0, 1), 1, prob = negotiation_ewa_b$probs), sample(c(0, 1), 1, prob = matching_ewa_b$probs))
} else{
pref_strats_b <- c(sample(c(0, 1), 1, prob = advertisement_ewa_b$probs),
sample(c(0, 1), 1, prob = negotiation_ewa_b$probs), sample(c(0, 1), 1, prob = matching_ewa_b$probs))
}
#return objects
if(!static_prefs){
return(list(a = list(pref_strats = pref_strats_a,
move_a = move_ewa_a$a,
advertisement_a = advertisement_ewa_a$a,
negotiation_a = negotiation_ewa_a$a,
matching_a = matching_ewa_a$a),
b = list(pref_strats = pref_strats_b,
move_a = move_ewa_b$a,
advertisement_a = advertisement_ewa_b$a,
negotiation_a = negotiation_ewa_b$a,
matching_a = matching_ewa_b$a)))
} else{
return(list(a = list(pref_strats = pref_strats_a,
advertisement_a = advertisement_ewa_a$a,
negotiation_a = negotiation_ewa_a$a,
matching_a = matching_ewa_a$a),
b = list(pref_strats = pref_strats_b,
advertisement_a = advertisement_ewa_b$a,
negotiation_a = negotiation_ewa_b$a,
matching_a = matching_ewa_b$a)))
}
}, mc.cores = cores)
#get preferred strategies of everyone in column 1 of duos, and then everyone in column 2
pref_strats <- do.call(rbind, c(lapply(1:(pop_size/2), function(x){coord_game_results[[x]]$a$pref_strats}),
lapply(1:(pop_size/2), function(x){coord_game_results[[x]]$b$pref_strats})))
#overwrite current preferences and strategies
if(!static_prefs){
agents$pref[c(duos$x, duos$y)] <- pref_strats[, 1]
agents$advertisement[c(duos$x, duos$y)] <- pref_strats[, 2]
agents$negotiation[c(duos$x, duos$y)] <- pref_strats[, 3]
agents$matching[c(duos$x, duos$y)] <- pref_strats[, 4]
} else{
agents$advertisement[c(duos$x, duos$y)] <- pref_strats[, 2]
agents$negotiation[c(duos$x, duos$y)] <- pref_strats[, 3]
agents$matching[c(duos$x, duos$y)] <- pref_strats[, 4]
}
#overwrite a values for preferences and strategies
if(!static_prefs){
agents$a_moves[c(duos$x, duos$y)] <- c(lapply(1:(pop_size/2), function(x){coord_game_results[[x]]$a$move_a}),
lapply(1:(pop_size/2), function(x){coord_game_results[[x]]$b$move_a}))
}
agents$a_advertisement[c(duos$x, duos$y)] <- c(lapply(1:(pop_size/2), function(x){coord_game_results[[x]]$a$advertisement_a}),
lapply(1:(pop_size/2), function(x){coord_game_results[[x]]$b$advertisement_a}))
agents$a_negotiation[c(duos$x, duos$y)] <- c(lapply(1:(pop_size/2), function(x){coord_game_results[[x]]$a$negotiation_a}),
lapply(1:(pop_size/2), function(x){coord_game_results[[x]]$b$negotiation_a}))
agents$a_matching[c(duos$x, duos$y)] <- c(lapply(1:(pop_size/2), function(x){coord_game_results[[x]]$a$matching_a}),
lapply(1:(pop_size/2), function(x){coord_game_results[[x]]$b$matching_a}))
#overwrite n
n <- observation(n, phi, kappa)
#remove objects
rm(list = c("duos", "coord_game_results", "pref_strats"))
#store output
output[[i]] <- agents
}
#return output
return(output)
}
#model plotting function, strategies or moves (strats = TRUE/FALSE)
plot_model <- function(output, colors = NULL, strats = TRUE, xlim = NULL){
if(strats){
#get all possible combinations of strategies
poss_patterns <- expand.grid(rep(list(c(0, 1)), 3))
poss_patterns <- sapply(1:nrow(poss_patterns), function(x){paste0(poss_patterns[x, ], collapse = "")})
#store pop_size and t from output
t <- ifelse(is.null(xlim), length(output), xlim)
pop_size <- nrow(output[[1]])
#convert output to matrix
output_mat <- sapply(1:t, function(x){as.numeric(table(factor(sapply(1:pop_size, function(y){paste0(output[[x]][y, 2:4], collapse = "")}), levels = poss_patterns)))})
#generate colors for plotting
if(is.null(colors)){colors <- c("black", distinctColorPalette(length(poss_patterns) - 1))}
#plot
par(mar = c(4, 4, 1, 1))
plot(1:t, output_mat[1,]/pop_size, ylim = c(0, 1), ylab = "Proportion", xlab = "Time", type = "l", col = colors[1], lwd = 2)
for(i in 2:nrow(output_mat)){lines(1:t, output_mat[i,]/pop_size, col = colors[i], lwd = 2)}
legend("topright", legend = poss_patterns, col = colors, pch = 19, ncol = 2)
} else{
#get number of moves
n_moves <- length(output[[1]]$a_moves[[1]])
#store pop_size and t from output
t <- ifelse(is.null(xlim), length(output), xlim)
pop_size <- nrow(output[[1]])
#convert output to matrix
output_mat <- sapply(1:t, function(x){as.numeric(table(factor(output[[x]]$pref, levels = 1:n_moves)))})
#generate colors for plotting
colors <- c("black", distinctColorPalette(n_moves - 1))
#plot
par(mar = c(4, 4, 1, 1))
plot(1:t, output_mat[1,]/pop_size, ylim = c(0, 1), ylab = "Proportion", xlab = "Time", type = "l", col = colors[1], lwd = 2)
for(i in 2:nrow(output_mat)){lines(1:t, output_mat[i,]/pop_size, col = colors[i], lwd = 2)}
legend("topright", legend = 1:n_moves, col = colors, pch = 19, ncol = 2)
}
}
low_neg_loss <- model(500, 200, priors = c(5, 0, 0, 0), phi = 0.5, neg_cost = 0, delta = 0.2, kappa = 0, lambda = 1, loss_averse = TRUE)
#load libraries
library(parallel)
library(randomcoloR)
low_neg <- model(500, 200, priors = c(5, 0, 0, 0), phi = 0.5, neg_cost = 0, delta = 0, kappa = 0, lambda = 1)
med_neg <- model(500, 200, priors = c(5, 0, 0, 0), phi = 0.5, neg_cost = 2, delta = 0, kappa = 0, lambda = 1)
high_neg <- model(500, 200, priors = c(5, 0, 0, 0), phi = 0.5, neg_cost = 4, delta = 0, kappa = 0, lambda = 1)
low_neg_loss <- model(500, 200, priors = c(5, 0, 0, 0), phi = 0.5, neg_cost = 0, delta = 0.2, kappa = 0, lambda = 1, loss_averse = TRUE)
med_neg_loss <- model(500, 200, priors = c(5, 0, 0, 0), phi = 0.5, neg_cost = 2, delta = 0.2, kappa = 0, lambda = 1, loss_averse = TRUE)
high_neg_loss <- model(500, 200, priors = c(5, 0, 0, 0), phi = 0.5, neg_cost = 4, delta = 0.2, kappa = 0, lambda = 1, loss_averse = TRUE)
plot_model(high_neg_loss)
plot_model(med_neg_loss)
plot_model(low_neg_loss)
plot(igraph::sample_pa(500, directed = FALSE, power = 1), vertex.label = "", vertex.color = "grey", vertex.size = 2)
plot(igraph::sample_pa(500, directed = FALSE, power = 1), vertex.label = "", vertex.color = "grey", vertex.size = 2)
plot(igraph::sample_pa(500, directed = FALSE, power = 3), vertex.label = "", vertex.color = "grey", vertex.size = 2)
plot(igraph::sample_pa(500, directed = FALSE, power = 2), vertex.label = "", vertex.color = "grey", vertex.size = 2)
plot(igraph::sample_pa(500, directed = FALSE, power = 1), vertex.label = "", vertex.color = "grey", vertex.size = 2)
plot(igraph::sample_pa(500, directed = FALSE, power = 0.5), vertex.label = "", vertex.color = "grey", vertex.size = 2)
plot(igraph::sample_pa(500, directed = FALSE, power = 0), vertex.label = "", vertex.color = "grey", vertex.size = 2)
plot(igraph::sample_pa(500, directed = FALSE, power = -2), vertex.label = "", vertex.color = "grey", vertex.size = 2)
?sample_pa
plot(igraph::sample_pa(20, directed = FALSE, power = -2), vertex.label = "", vertex.color = "grey", vertex.size = 2)
plot(igraph::sample_pa(20, directed = FALSE, power = 2), vertex.label = "", vertex.color = "grey", vertex.size = 2)
plot(igraph::sample_pa(20, directed = FALSE, power = 3), vertex.label = "", vertex.color = "grey", vertex.size = 2)
plot(igraph::sample_pa(20, directed = FALSE, power = 4), vertex.label = "", vertex.color = "grey", vertex.size = 2)
plot(igraph::sample_pa(20, directed = FALSE, power = 5), vertex.label = "", vertex.color = "grey", vertex.size = 2)
plot(igraph::sample_pa(20, directed = FALSE, power = 1), vertex.label = "", vertex.color = "grey", vertex.size = 2)
plot(igraph::sample_pa(20, directed = FALSE, power = 0.5), vertex.label = "", vertex.color = "grey", vertex.size = 2)
plot(igraph::sample_pa(20, directed = FALSE, power = 0.1), vertex.label = "", vertex.color = "grey", vertex.size = 2)
plot(igraph::sample_pa(20, directed = FALSE, power = 0), vertex.label = "", vertex.color = "grey", vertex.size = 2)
plot(igraph::sample_pa(20, directed = FALSE, power = 1, m = 2), vertex.label = "", vertex.color = "grey", vertex.size = 2)
plot(igraph::sample_pa(20, directed = FALSE, power = 1, m = 3), vertex.label = "", vertex.color = "grey", vertex.size = 2)
plot(igraph::sample_pa(20, directed = FALSE, power = 1, m = 4), vertex.label = "", vertex.color = "grey", vertex.size = 2)
plot(igraph::sample_pa(20, directed = FALSE, power = 1, m = 1), vertex.label = "", vertex.color = "grey", vertex.size = 2)
plot(igraph::sample_pa(20, directed = FALSE, power = 1, m = 2), vertex.label = "", vertex.color = "grey", vertex.size = 2)
plot(igraph::sample_pa(500, directed = FALSE, power = 1, m = 2), vertex.label = "", vertex.color = "grey", vertex.size = 2)
plot(igraph::sample_pa(500, directed = FALSE, power = 1, m = 1.5), vertex.label = "", vertex.color = "grey", vertex.size = 2)
plot(igraph::sample_pa(500, directed = FALSE, power = 1, m = 1.6), vertex.label = "", vertex.color = "grey", vertex.size = 2)
plot(igraph::sample_pa(500, directed = FALSE, power = 1, m = 1.8), vertex.label = "", vertex.color = "grey", vertex.size = 2)
plot(igraph::sample_pa(500, directed = FALSE, power = 1, m = 1.9), vertex.label = "", vertex.color = "grey", vertex.size = 2)
plot(igraph::sample_pa(500, directed = FALSE, power = 1, m = 4), vertex.label = "", vertex.color = "grey", vertex.size = 2)
plot(igraph::sample_pa(500, directed = FALSE, power = 1, m = 2), vertex.label = "", vertex.color = "grey", vertex.size = 2)
igraph::degree(igraph::sample_pa(500, directed = FALSE, power = 1, m = 2))
mean(igraph::degree(igraph::sample_pa(500, directed = FALSE, power = 1, m = 2)))
mean(igraph::degree(igraph::sample_pa(500, directed = FALSE, power = 1, m = 2)))
mean(igraph::degree(igraph::sample_pa(500, directed = FALSE, power = 1, m = 1)))
mean(igraph::degree(igraph::sample_pa(500, directed = FALSE, power = 1, m = 2)))
mean(igraph::degree(igraph::sample_pa(5000, directed = FALSE, power = 1, m = 2)))
median(igraph::degree(igraph::sample_pa(5000, directed = FALSE, power = 1, m = 2)))
hist(rgamma(1000, 1))
hist(rgamma(1000, 1))
hist(rgamma(1000, 1))
hist(rgamma(1000, 2))
hist(rgamma(1000, 3))
hist(rgamma(1000, 6))
hist(rgamma(1000, 5))
hist(rgamma(1000, 4))
hist(rgamma(1000, 3))
hist(rgamma(1000, 4))
hist(rgamma(1000, 5))
hist(rgamma(1000, 5), breaks = 100)
hist(rgamma(100000, 5), breaks = 100)
hist(rgamma(100000, 5), breaks = 100, xlim = c(0, 20))
hist(rgamma(100000, 4), breaks = 100, xlim = c(0, 20))
hist(rgamma(100000, 3), breaks = 100, xlim = c(0, 20))
hist(rgamma(100000, 2), breaks = 100, xlim = c(0, 20))
hist(rgamma(100000, 1), breaks = 100, xlim = c(0, 20))
hist(rgamma(100000, 2), breaks = 100, xlim = c(0, 20))
hist(rgamma(100000, 3), breaks = 100, xlim = c(0, 20))
hist(rgamma(100000, 4), breaks = 100, xlim = c(0, 20))
rnorm(10000, 5, 1)
hist(rnorm(10000, 5, 1))
hist(rnorm(100000, 5, 1))
max(rnorm(100000, 5, 1))
max(rnorm(100000, 5, 1))
max(rnorm(100000, 5, 1))
max(rnorm(100000, 5, 1))
max(rnorm(100000, 5, 1))
max(rnorm(1000000, 5, 1))
max(rnorm(10000000, 5, 1))
max(rnorm(100000000, 5, 1))
setwd("~/Documents/Work/Fall 2022/Conservatism/ConservatismModel")
source("functions.R")
load("/Users/masonyoungblood/Documents/Work/Fall 2022/Conservatism/hpcc_output/output/loss_final.RData")
final
final[[1]]
final[[1]]$a_moves
final[[10]]$a_moves
final[[100]]$a_moves
final[[100]]$a_moves[1]
hist(final[[100]]$a_moves[1])
final[[100]]$a_moves
sapply(1:nrow(final[[100]]), function(x){})
final[[100]]$a_moves
final[[100]]$a_moves[[1]]
sapply(1:nrow(final[[100]]), function(x){final[[100]]$a_moves[[x]][1]})
hist(sapply(1:nrow(final[[100]]), function(x){final[[100]]$a_moves[[x]][1]}))
hist(sapply(1:nrow(final[[100]]), function(x){final[[100]]$a_moves[[x]][1]}), xlab = "")
hist(sapply(1:nrow(final[[100]]), function(x){final[[100]]$a_moves[[x]][2]}), xlab = "")
hist(sapply(1:nrow(final[[100]]), function(x){final[[100]]$a_moves[[x]][1]}), xlab = "")
load("/Users/masonyoungblood/Documents/Work/Fall 2022/Conservatism/hpcc_output/output/base_final.RData")
hist(sapply(1:nrow(final[[100]]), function(x){final[[100]]$a_moves[[x]][1]}), xlab = "")
hist(sapply(1:nrow(final[[100]]), function(x){final[[100]]$a_moves[[x]][2]}), xlab = "")
hist(sapply(1:nrow(final[[100]]), function(x){final[[100]]$a_moves[[x]][3]}), xlab = "")
hist(sapply(1:nrow(final[[100]]), function(x){final[[100]]$a_moves[[x]][4]}), xlab = "")
hist(sapply(1:nrow(final[[100]]), function(x){final[[100]]$a_moves[[x]][1]}), xlab = "")
hist(sapply(1:nrow(final[[100]]), function(x){final[[100]]$a_moves[[x]][1]}), xlab = "")
